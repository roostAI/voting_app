// Test generated by RoostGPT for test zb-js-test using AI Type Open AI and AI Model gpt-4

const { register } = require('./serviceWorker');

describe('serviceWorker', () => {
  let env;
  let addEventListenerMock;
  let consoleLogMock;
  let navigatorMock;

  beforeEach(() => {
    env = process.env;
    process.env = { ...env, NODE_ENV: 'production', PUBLIC_URL: 'http://localhost' };
    addEventListenerMock = jest.spyOn(window, 'addEventListener');
    consoleLogMock = jest.spyOn(console, 'log');
    navigatorMock = jest.spyOn(navigator, 'serviceWorker', 'get');
  });

  afterEach(() => {
    process.env = env;
    jest.restoreAllMocks();
  });

  test('should not register when not in production environment', () => {
    process.env.NODE_ENV = 'development';
    register();
    expect(addEventListenerMock).not.toHaveBeenCalled();
  });

  test('should not register when serviceWorker is not in navigator', () => {
    navigatorMock.mockReturnValue(undefined);
    register();
    expect(addEventListenerMock).not.toHaveBeenCalled();
  });

  test('should not register when PUBLIC_URL is on a different origin', () => {
    process.env.PUBLIC_URL = 'http://different-origin';
    register();
    expect(addEventListenerMock).not.toHaveBeenCalled();
  });

  test('should register when in production environment and serviceWorker in navigator', () => {
    navigatorMock.mockReturnValue({ ready: Promise.resolve() });
    register();
    expect(addEventListenerMock).toHaveBeenCalledWith('load', expect.any(Function));
  });

  test('should log message when service worker is ready and app is running on localhost', async () => {
    navigatorMock.mockReturnValue({ ready: Promise.resolve() });
    register();
    const loadListener = addEventListenerMock.mock.calls.find(([event]) => event === 'load')[1];
    await loadListener();
    expect(consoleLogMock).toHaveBeenCalled();
  });
});
