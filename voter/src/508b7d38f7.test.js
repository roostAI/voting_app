// Test generated by RoostGPT for test zb-js-test using AI Type Open AI and AI Model gpt-4

import React from 'react';
import { shallow } from 'enzyme';
import Home from './Home';

describe('Home Component', () => {
  let wrapper;
  let mockFetch;

  beforeEach(() => {
    mockFetch = jest.fn(() => Promise.resolve({
      json: () => Promise.resolve({}),
    }));
    global.fetch = mockFetch;

    wrapper = shallow(<Home />);
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  test('should update state when candidate_id changes', () => {
    wrapper.setState({ candidate_id: '1', voter_id: '1' });
    wrapper.instance().componentDidUpdate({ candidate_id: '2' }, {});

    expect(mockFetch).toHaveBeenCalled();
    expect(mockFetch.mock.calls[0][0]).toContain('http:');
    expect(mockFetch.mock.calls[0][1].method).toEqual('POST');
    expect(JSON.parse(mockFetch.mock.calls[0][1].body)).toEqual({ candidate_id: '1', vote: '1' });
  });

  test('should not make a fetch call when ballot_endpoint is empty', () => {
    wrapper.setState({ candidate_id: '1', voter_id: '1' });
    global.ballot_endpoint = '';

    wrapper.instance().componentDidUpdate({ candidate_id: '2' }, {});

    expect(mockFetch).not.toHaveBeenCalled();
  });

  test('should update state when showResultsButton changes', () => {
    jest.useFakeTimers();
    wrapper.setState({ showResultsButton: true });

    wrapper.instance().componentDidUpdate({ showResultsButton: false }, {});

    expect(setTimeout).toHaveBeenCalledTimes(1);
    expect(setTimeout).toHaveBeenLastCalledWith(expect.any(Function), 3000);
  });
});
